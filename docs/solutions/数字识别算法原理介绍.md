# 数字识别

2018级 方嘉慧颖

主要有两种方式：（无流程图）

**方式一：SVM模板匹配**

```cpp
Ptr<ml::SVM> svm = Algorithm::load<ml::SVM>(SVM_PATH);
HOGDescriptor* hog = new HOGDescriptor(Size(40, 40), Size(20, 20), Size(10, 10), Size(10, 10), 9);
//HOGDescriptor* hog = new HOGDescriptor(Size(9, 9), Size(6, 6), Size(3, 3), Size(3, 3), 9);
//HOGDescriptor* hog = new HOGDescriptor(Size(6, 6), Size(6, 6), Size(3, 3), Size(3, 3), 9);
vector<float> descriptors;
```

流程：

1. 使用`depart_img()`，通过透射变换将目标装甲转换为正常`rect`图像（40x40）.

2. 使用hog提取特征。

3. 转换为SVM所需的单列图像后，进行匹配。

4. 返回匹配结果。  



**方式二：欧氏距离识别：**

1. 使用`adaptiveThreshold()`函数，根据图像不同区域亮度分布，计算出领域的高斯阈值

2. 使用`morphologyEx()`函数，调用`MORPH_OPEN`，对图片进行`size(3,3)`的开运算处理。

3. 计算处理图的平均值，若小于阈值，则说明是负样本，返回0；若大于阈值，则：

    1. 使用`morphologyEx()`函数，调用`MORPH_OPEN`，对图片进行`size(2,2)`的开运算处理。

    2. 使用`resize()`函数将图片高度调整为和模板一致。

    3. 使用`copyMakeBorder()`函数将图片宽度填补为为和模板宽度一致。

    4. 使用`norm()`函数分别计算待测图片与模板的欧氏距离，判定距离最小的模板所对应的数字为检测出的数字结果。

4. 返回匹配结果。